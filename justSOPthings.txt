So here we have focused on implementing these checks in the database itself through SQL Procedures. We store all updates to the databases, including metadata, in a permissioned blockchain. Each node, cut off from any direct user interaction, contains a replica of the database and has a backend server running which polls the blockchain at regular intervals for transactions to execute or whenever there is an explicit request from a user (we implement this using the Select system call) to do so in order to avoid latency. We have also implemented Inter Database integrity using Merkle trees to detect any inconsistency if a node gets hacked. We traverse the Merkle tree to retrieve those particular data items which led to the disparity between the databases.